[TOC]

业界高并发系统



异步

Welink ops



高并发思想



项目的痛点

cac：可靠性







## 分层架构（边界清晰、单一职责）

不分层的坏处

逻辑不清晰、各模块互相依赖、代码扩展性差

分层的好处

简化系统设计、复用、容易做横向扩展

分层的缺点

增加了代码复杂度、性能损耗

### 常见的分层架构

MVC架构

表现层、逻辑层、数据访问层

OSI网络模型、TCP/IP网络分层

Linux文件系统：虚拟文件系统（VFS）、Ext3、Ext4文件系统，通用块设备（上层对下层不同实现的抽象，屏蔽实现细节）

《阿里巴巴Java开发手册》 -系统分层







## 高并发系统设计的三大目标

高并发是背景和前提，是指能够处理更多请求，承担更大的流量。

- 高性能：响应时间
- 高可用（High Availability，HA）：（99.999%）
- 可扩展：扩容

配置管理系统，更多的追求高可用，不追求极致性能。



### 性能的度量指标

例如：在每秒1万次的请求量下，响应时间99分位值在10ms以下

吞吐量

响应时间：200ms、1s

### 高并发下的性能优化

1. 提高系统的处理核心数
2. 减少单次任务响应时间
   1. CPU密集型
      1. 优化算法
      2. Profile工具寻找消耗CPU时间最多的方法和模块
   2. IO密集型：磁盘IO、网络IO
      1. Java内存分析工具



### 可用性的度量

MTBF：平均故障间隔

MTTR：故障平均恢复时间

```
Availability = MTBF / （MTBF + MTTR）
```

4个9:完善的运维值班体系、故障处理流程、业务变更流程。故障快速排查。

5个9: 容灾、自动恢复能力

### 高可用系统设计的思路

#### 系统设计（冗余、取舍）

- failover故障转移
  - 故障检测机制：心跳
  - 选主：分布式一致性算法
- 超时控制 （牺牲少量请求，保证整体系统可用性）
- 降级
- 限流

#### 系统运维

-  灰度发布（90%故障发生在上线变更阶段）
- 故障演练





## 数据库

池化技术

主从分离

分库分表

ID全局唯一

NoSql

## 缓存

缓存读写策略

高可用

缓存穿透

CDN

## 消息队列

把消息队列看作暂时存储数据的一个容器，认为它是一个平衡低速系统和高速系统处理任务时间差的工具



### 秒杀系统中消息队列的作用

1. 削峰填谷：对峰值写流量做削峰填谷
2. 异步处理：对次要的业务逻辑做异步处理，
3. 解耦合：对不同的系统模块。



### 如何保证消息仅仅被消费一次？不丢失，不重复

#### 消息可能会丢失的3个阶段

- 消息从生产者写入到消息队列的过程
  - 重传。重传可能导致重复

- 消息在消息队列中的存储场景
  - 以集群方式部署 Kafka 服务，通过部署多个副本备份数据保证消息尽量不丢失。
  - 配置当所有 ISR Follower 都接收到消息才返回成功

- 消息被消费者消费的过程

  - 保证在消息的生产和消费的过程是“幂等”的。
  - 生产端的保证：给生产的消息一个唯一的ID，消息队列中对比ID是否重复。（kafka支持次功能）
  - 消费端的保证：消息生产时生成一个唯一ID，消息处理时把ID存储在数据库中。
  - 引入事务：保证消息处理和写入数据库必须同时成功或者同时失败
  - 数据库乐观锁，使用版本号

  

### 如何降低消息队列中消息的延迟

### 

