[TOC]



## volatile

- 作用

  1. 用于保证多线程共享变量的可见性，当一条线程修改了这个变量值，新值对于其他线程立即可见。volatile变量在各个线程的工作内存中不存在一致性问题。
  2. 有序性（禁止指令重排序）

  无法保证线程安全，因为Java里面的运算并非原子操作。线程获取到volatile变量，再写回主内存时，变量值可能已经被其他线程修改了。

- 指令重排序

  编译器和处理器为了优化程序执行的性能而对指令序列进行重排的一种手段。现象就是CPU 执行指令的顺序可能和程序代码的顺序不一致，例如 `a = 1; b = 2;` 可能 CPU 先执行`b=2;` 后执行`a=1;`

  指令重排序也遵循一定的规则：

  1. 重排序不会对存在依赖关系的操作进行重排
  2. 重排序目的是优化性能，不管怎样重排，单线程下的程序执行结果不会变



### 使用volatile的场景

- 使用原则：

  - 对变量的写操作不依赖于当前值。例如 i++ 这种就不适用。

  - 该变量没有包含在具有其他变量的不变式中。

    单个的共享变量的读/写（比如a=1）具有原子性，但是像`num++`或者`a=b+1;`这种复合操作，volatile无法保证其原子性；

  AQS里面的state、waitstatus

```java
      /**
       * The synchronization state.
       */
      private volatile int state;

      static final class Node {
        volatile int waitStatus;
      }
```

2. 状态标志 （异步任务框架）

   比如我们工程中经常用一个变量标识程序是否启动、初始化完成、是否停止等。volatile 很适合只有一个线程修改，其他线程读取的情况。volatile 变量被修改之后，对其他线程立即可见。

3. double-check 的单例模式

   使用volatile 修饰保证 singleton 的实例化能够对所有线程立即可见。

   1. 为什么使用volatile 修饰了singleton 引用还用synchronized 锁？

      对象创建singleton = new Singleton() 不是原子操作。由3步组成：

      步骤1：在堆内存申请一块内存空间；

      步骤2：初始化申请好的内存空间；

      步骤3：将内存空间的地址赋值给 singleton；

      如果不加锁可能会初始化多次。

   2. 为什么用了synchronized还要用volatile？

      synchronized不禁止指令重排序，可能发生变量先赋值后初始化的情况。

   3. 第一次检查singleton 为空后为什么内部还需要进行第二次检查？

      防止singleton初始化多次。

   4. volatile 除了内存可见性，还有别的作用吗？

      singleton = new Singleton();` 由三步操作组合而成，如果不使用volatile 修饰，可能发生指令重排序。步骤3 在步骤2 之前执行，singleton 引用的是还没有被初始化的内存空间，别的线程调用单例的方法就会引发未被初始化的错误。

### 底层实现原理

- 内存屏障技术，解决缓存一致性问题。

  为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障指令，内存屏障效果有：

  - 禁止volatile 修饰变量指令的重排序
  - 写入数据强制刷新到主存
  - 读取数据强制从主存读取

主存

CPU高速缓存：存放20%常用数据和指令

多级缓存（Cache Line）

![img](/Users/fanxudong/IdeaProjects/blog/4 Java/assert/多核CPU架构.png)

CPU 访问主存数据时存在二个局部性现象：

1. 时间局部性现象

   如果一个主存数据正在被访问，那么在近期它被再次访问的概率非常大。想想你程序大部分时间是不是在运行主流程。

2. 空间局部性现象

   CPU使用到某块内存区域数据，这块内存区域后面临近的数据很大概率立即会被使用到。这个很好解释，我们程序经常用的数组、集合（本质也是数组）经常会顺序访问（内存地址连续或邻近）。



### Java内存模型（JMM）

- 为什么要java内存模型

  计算机中为了解决CPU、内存、IO三者之间访问效率问题，引入了高速缓存（Cache），另外还会通过指令重排序对CPU运算进行优化。从而引入了缓存一致性问题，和指令乱序的问题。

- 什么是JMM

  所谓内存模型，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型。

  Java内存模型 是Java 定义的一套协议，用来屏蔽各种硬件和操作系统的**内存**访问差异，让Java 程序在各种平台都能有一致的运行效果。

  CPU 有X86（复杂指令集）、ARM（精简指令集）等体系架构，版本类型也有很多种，CPU 可能通过锁总线、MESI 协议实现多核心缓存的一致性。因为有硬件的差异以及编译器和处理器的指令重排优化的存在，所以Java 需要一种协议来规避硬件平台的差异，保障同一段代表在所有平台运行效果一致，这个协议叫做Java 内存模型（Java Memory Model）。

- 协议的实现细节


- 定义

  所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量（主内存的拷贝），线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。

  不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。

  (工作内容中操作变量，主内存中存储和传递变量)

  <img src="/Users/fanxudong/IdeaProjects/blog/4 Java/assert/image-20200531154502649.png" alt="image-20200531154502649" style="zoom:50%;" />

  

- JMM与真实内存架构

  ![img](/Users/fanxudong/IdeaProjects/blog/4 Java/assert/JMM与真实内存架构.png)

  通过JMM来理解可见性、原子性、有序性问题的存在，关键字volatile怎么解决可见性有序性问题。

- 内存模型规范定义：

```
在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。
```

- 实现原理：

内存屏障



JUC包实现原子性问题：CAS指令

### 重排序





###  参考

[一个volatile跟面试官扯了半个小时](https://mp.weixin.qq.com/s/mRjg07M8FsjnVRu_fP-27w) 

《深入理解Java虚拟机》

#### 12章 Java内存模型与线程

##### 12.1 概述

##### 12.2 硬件的效率与一致性

##### 12.3 Java内存模型 （Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的）

###### 12.3.1 主存与工作内存

###### 12.3.2 内存间交互操作 

​	8种原子操作：lock、unlock、read、load、use、assign、store、write

​	主存 -》 工作内存：read ->load;工作内存 -》 主存：store -〉 write

<img src="/Users/fanxudong/IdeaProjects/blog/4 Java/assert/image-20200531185057593.png" alt="image-20200531185057593" style="zoom:50%;" />

​	8种操作需要满足的规则  + volatile型变量的特殊规则：确定了哪些内存访问操作在并发下是安全的。可通过等效的先行发生原则来判断。

###### 12.3.3 对于volatile型变量的特殊规则

###### 12.3.4 对于long和double型变量的特殊规则

###### 12.3.5 原子性、可见性、有序性

###### 12.3.6 先行发生原则（happens-before）

​	判断数据时否存在竞争、线程是否安全的主要依据。先行发生关系无须任何同步器协助就已经存在。



##### 12.4 Java与线程

###### 12.4.1 线程实现

1.使用内核线程实现

2.使用用户线程实现

3.使用用户线程加轻量级进程混合实现

4.java的线程实现

###### 12.4.2 Java线程调度

###### 12.4.3 状态转换

#### 13章 线程安全与锁优化

##### 13.1概述

##### 13.2线程安全

###### 13.2.1Java语言中的线程安全

1.不可变

2.绝对线程安全

3.相对线程安全

4.线程兼容

5.线程对立

###### 13.2.2线程安全的实现方法

1.互斥同步（synchronized、ReentrantLock）阻塞同步，线程阻塞和唤醒带来性能开销。悲观

2.非阻塞同步

3.无同步方法

​	可重入代码

​	线程本地存储





​	

