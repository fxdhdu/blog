[TOC]



## 对象存活判定算法

### 引用计数算法

- 给对象添加一个引用计数器，引用对象时，计数器加1，引用失效时，计数器减1。
- 很难解决对象间循环引用的问题。

### 可达性分析算法

- 对象到GC Roots对象不可达，或则说没有引用链，则对象不可用。
- 4种GC Roots对象
    1. 方法区的类静态属性
    2. 方法区的常量引用的对象
    3. 虚拟机栈中引用的对象
    4. 本地方法栈中JNI引用的对象

### HotSpot算法实现

- 安全点
程序执行时，到达安全点时才能GC
当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。

- 安全区域
引用关系不会发生变化的代码区域



## 垃圾搜集算法     

### 标记-清除算法

- 标记出所有需要回收的对象，并统一回收
- 效率低，产生大量内存碎片

### 复制算法

- 用于新生代的回收。将新生代分为一块Eden和两块Survivor，比例为8:1:1
- Survivor空间不够时，需要老年代进行分配担保

### 标记-整理算法

- 标记出所有需要回收的对象，将所有对象向一端移动，回收边界以外的内存

### 分代收集算法

- 新生代使用复制算法
- 老年代使用 标记-清理 或 标记-整理 算法

## 垃圾收集器

### CMS收集器

1. 初始标记 stop the word
2. 并发标记 concurrent mark
3. 重新标记 stop the word
4. 并发清理 concurrent sweep

![image-20200602080924217](./assert/image-20200602080924217.png)

### G1收集器

1. 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。
2. 并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。
3. 最终标记：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
4. 筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

![image-20200602081135408](./assert/image-20200602081135408.png)



## GC调优

GC tuning is the last task to be done.

调优的目的：内存占用、延时（停顿导致延迟上升）、吞吐量（GC线程占用一部分CPU资源）

1. 将进入老年代的对象数量降到最低
2. 减少Full GC的执行时间



1. 先优化应用程序以减少GC负担，再启动GC参数优化。
2. 使用 StringBuilder或 StringBuffer来代替 String
3. 尽量少输出日志（什么日志？）
XML和JSON解析过程往往占用了最多的内存，用于解析XML或JSON文件的临时内存（大约10-100MB）。



## 参考

[jvm系列(九):如何优化Java GC](https://mp.weixin.qq.com/s/ydkEkh_Uc1paftJLKIsm0w)

