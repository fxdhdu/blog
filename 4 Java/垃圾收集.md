[TOC]



## 对象存活判定算法

### 引用计数算法

- 给对象添加一个引用计数器，引用对象时，计数器加1，引用失效时，计数器减1。
- 很难解决对象间循环引用的问题。

### 可达性分析算法

- 对象到GC Roots对象不可达，或则说没有引用链，则对象不可用。
- 4种GC Roots对象
    1. 方法区的类静态属性
    2. 方法区的常量引用的对象
    3. 虚拟机栈中引用的对象
    4. 本地方法栈中JNI引用的对象

### HotSpot算法实现

- 安全点
程序执行时，到达安全点时才能GC
- 安全区域
引用关系不会发生变化的代码区域



## 垃圾搜集算法     

### 标记-清除算法

- 标记出所有需要回收的对象，并统一回收
- 效率低，产生大量内存碎片

### 复制算法

- 用于新生代的回收。将新生代分为一块Eden和两块Survivor，比例为8:1:1
- Survivor空间不够时，需要老年代进行分配担保

### 标记-整理算法

- 标记出所有需要回收的对象，将所有对象向一端移动，回收边界以外的内存

### 分代收集算法

- 新生代使用复制算法
- 老年代使用 标记-清理 或 标记-整理 算法

## 垃圾收集器

### CMS收集器

### G1收集器



## GC调优

GC tuning is the last task to be done.

调优的目的：内存占用、延时、吞吐量

1. 将进入老年代的对象数量降到最低
2. 减少Full GC的执行时间



1. 先优化应用程序以减少GC负担，再启动GC参数优化。
2. 使用 StringBuilder或 StringBuffer来代替 String
3. 尽量少输出日志（什么日志？）
XML和JSON解析过程往往占用了最多的内存，用于解析XML或JSON文件的临时内存（大约10-100MB）。



## 参考

[jvm系列(九):如何优化Java GC](https://mp.weixin.qq.com/s/ydkEkh_Uc1paftJLKIsm0w)

