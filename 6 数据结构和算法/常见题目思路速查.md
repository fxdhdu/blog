NC是牛客网上的题目编号。



## 链表

1. 反转链表：用循环或递归。循环时，定义3个指针，不需要哨兵。
2. **链表中的节点每k个一组翻转：**
3. 链表中判断是否有环：快慢指针相遇法判断。指针先相遇表示有环，指针先为空表示无环。
4. 链表中环的入口节点：快慢指针法，相遇后再从表头派出第3个指针，与慢指针相遇点就是入口。快慢指针都从head开始跑，循环中先跑再判断是否相等。（这题快慢指针不在同一个起点会无限循环哦）
5. 两个链表的第一个公共结点（NC66）：两个链表第一个公共节点之后的链表相同，双指针法，指针第一次到达链表尾部后，换个链表继续遍历，当两个指针相遇时，就是链表公共节点。（注意点是连个指针都至少做一次交换）
6. 合并有序链表：设置一个哨兵，把两个链表中较小的节点不断往哨兵后面追加。
7. 合并两个有序的数组：A数组有足够的空间可以放下AB两个数组的元素。从A数组的末尾开始放，每次把较大的元素放过去。
8. 两个链表生成相加链表(NC40): 数字是正序存储的，高位在链表头，低位在表尾。需要反转链表后再计算，不要忘记最后的进位。
9. 两数相加（leetcode2）：两个链表相加，数字是逆序存储的，高位在链表末尾，低位在表头。返回结果生成一个新的链表。
10. 删除链表的倒数第n个节点：先走n步法，先走指针为null时则找到了。不用计算长度。但要一个pre节点。使用哨兵guard，防止链表只有一个节点，删除后就没了。

## 树

1. 实现二叉树先序，中序和后序遍历
2. 求二叉树的层序遍历：队列
3. 二叉树的之字形层序遍历（NC14）/二叉树的锯齿形层序遍历（leetcode103）：使用两个栈，从左往右遍历时，先放入左子树，从右往左遍历时，先放入右子树。
4. **最近公共祖先（NC102）**：返回二叉树中两个节点的最近公共祖先节点。后根序遍历，这样可以保证最近（即深度最大）。2中方法：1.递归函数返回找到的o1或o2的个数。 2.递归函数返回o1/o2或答案。
5. 二叉搜索树的最近公共祖先（leetcode235）：由于是二叉搜索树，所以比二叉树的情况下更简单。答案在左子树？答案在右子树？否则当前节点就是答案。
6. 重建二叉树（NC12）：根据前序遍历和中序遍历，重建二叉树。找根节点，然后分别递归重建左右子树。



## 动态规划

1. 跳台阶：一次上一级或二级台阶，问有几种上法。dp[n] = dp[n-1] + dp[n-2]
2. 子数组的最大累加和问题：dp[i] 为以i元素结束的这个数组的子数组的最大累加和。dp = Math.max(dp + arr[i], arr[i]); 并记录最大值。
3. **最长公共子串：计算两个字符串的最长公共子串。**dp[i] [j] 的含义是：以s1[i]和s2[j] 为最后一个元素的最长公共子串。dp[i] [j] = dp[i-1] [j-1] + 1 ，s1[i] == s2[j]时；dp[i] [j] = 0，s1[i] ！= s2[j]时
4. 最长公共子序列（leetcode1143）  ：返回这两个字符串的最长公共子序列的长度。dp[i] [j] 的含义是：对于 s1[1..i] 和 s2[1..j]，它们的最长公共子序列的长度是dp[i] [j]。dp[i] [j] = dp[i-1] [j-1] + 1 ，str1[i - 1] == str2[j - 1]时；dp[i] [j] = Math.max(dp[i-1] [j], dp[i] [j-1]) , 其他。
5. **最长递增子序列（leetcode300）**：子序列不用连续。需要输出字典序最小的子序列。定义 dp[i] 为考虑前 i 个元素，以第 i个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。 *dp*[*i*]=max(*dp*[*j*])+1, 其中0≤*j*<*i*且*num*[*j*]<*num*[*i*]，时间复杂度是O(n^2)，双重for循环。
6. **最长递增子序列的个数（leetcode673）**
7. 最长递增子序列（NC91）：NC91比leetcode300难度高，这题需要输出子序列，且子序列有多个时，需要字典序最小的。
8. **最长回文子串（NC17 、leetcode5）**：dp[i] [j]  s[i..j] 是否是回文串。 i==j时，字符串长度为1，dp[i] [j] = true; j = i + 1时，字符串长度为2，两个字符相等则为回文。字符串长度>=3时，dp[i] [j] = dp[i+1] [j-1]  && s[i] == s[j]



1. 最长无重复子串：滑动窗口公式：条件满足则right++，更新最大值；条件不满足则left++，直到满足为止。
2. 两数之和：使用一个HashMap记录已经遍历过的值。
3. 用两个栈实现队列：一个栈进元素，一个栈出元素。
4. 括号序列：判断给出的字符串是否是合法的括号序列。遇到匹配的则pop，否则就push，最后判断stack是否为空。
5. 快速排序：递归，非递归实现。（pivot、partition、swap）
6. **最小的K个数**：快排，找出pivot后直接返回？
7. 寻找第K大：快排，找出pivot后直接返回。
8. 二分查找。（求mid再判断区间）
9. **设计LRU缓存结构：**
   1. 继承LinkedHashMap（太简单，不符合面试要求），覆盖removeEldestEntry方法。
   2. 不继承LinkedHashMap实现，同时要自定义链表结构。使用HashMap + 自定义结构的双向链表。双向链表实现头部插入/尾部删除/移动节点到头部等方法。双向链表头尾节点使用两个哨兵。（是否可以使用linkedlist？）
10. 大数加法(NC1)：两个字符串数字相加，返回字符串。
11. 反转字符串(NC103)
12. 求平方根（NC32）：计算并返回x的平方根（向下取整），可以用二分查找。
13. 螺旋矩阵（NC38、leetcode54）：按螺旋的顺序返回矩阵中的所有元素。思路简单实现容易出错。

