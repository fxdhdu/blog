1. 反转链表：用循环或递归。循环时，定义3个指针。
2.  **链表中的节点每k个一组翻转：**
3. 链表中判断是否有环：使用快慢指针相遇法判断。指针先相遇表示有环，指针先为空表示无环。
4. 链表中环的入口节点：快慢指针法，相遇后再从表头派出第3个指针，与慢指针相遇点就是入口。快慢指针都从head开始跑，循环中先跑再判断是否相等。（这题快慢指针不在同一个起点会无限循环哦）
5. 合并有序链表：设置一个哨兵，把两个链表中较小的节点不断往哨兵后面追加。
6. 合并两个有序的数组：A数组有足够的空间可以放下AB两个数组的元素。从A数组的末尾开始放，每次把较大的元素放过去。
7. 两个链表生成相加链表(NC40): 数字是正序存储的，高喂在链表头，低位在表尾。返回结果
8. 两数相加（leetcode2）：两个链表相加，数字是逆序存储的，高位在链表末尾，低位在表头。返回结果生成一个新的链表。
9. 删除链表的倒数第n个节点：先走n步法，先走指针为null时则找到了。不用计算长度。但要一个pre节点。使用哨兵guard，防止链表只有一个节点，删除后就没了。
10. 实现二叉树先序，中序和后序遍历
11. 求二叉树的层序遍历：队列
12. 用两个栈实现队列：一个栈进元素，一个栈出元素。
13. 括号序列：判断给出的字符串是否是合法的括号序列。遇到匹配的则pop，否则就push，最后判断stack是否为空。
14. 快速排序：递归，非递归实现。（pivot、partition、swap）
15. **最小的K个数**：快排，找出pivot后直接返回？
16. 寻找第K大：快排，找出pivot后直接返回。
17. 二分查找。（求mid再判断区间）
18. **设计LRU缓存结构：**
    1. 继承LinkedHashMap（太简单，不符合面试要求），覆盖removeEldestEntry方法。
    2. 不继承LinkedHashMap实现，同时要自定义链表结构。使用HashMap + 自定义结构的双向链表。双向链表实现头部插入/尾部删除/移动节点到头部等方法。双向链表头尾节点使用两个哨兵。（是否可以使用linkedlist？）
19. 跳台阶：一次上一级或二级台阶，问有几种上法。dp[n] = dp[n-1] + dp[n-2]
20. 子数组的最大累加和问题：dp[i] 为以i元素结束的这个数组的子数组的最大累加和。dp = Math.max(dp + arr[i], arr[i]); 并记录最大值。
21. **最长公共子串：计算两个字符串的最长公共子串。**dp[i] [j] 的含义是：以s1[i]和s2[j] 为最后一个元素的最长公共子串。dp[i] [j] = dp[i-1] [j-1] + 1 ，s1[i] == s2[j]时；dp[i] [j] = 0，s1[i] ！= s2[j]时
22. 最长公共子序列（leetcode1143）  ：返回这两个字符串的最长公共子序列的长度。dp[i] [j] 的含义是：对于 s1[1..i] 和 s2[1..j]，它们的最长公共子序列的长度是dp[i] [j]。dp[i] [j] = dp[i-1] [j-1] + 1 ，str1[i - 1] == str2[j - 1]时；dp[i] [j] = Math.max(dp[i-1] [j], dp[i] [j-1]) , 其他。
23. **最长递增子序列（leetcode300）**：子序列不用连续。需要输出字典序最小的子序列。定义 dp[i] 为考虑前 i 个元素，以第 i个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。 *dp*[*i*]=max(*dp*[*j*])+1, 其中0≤*j*<*i*且*num*[*j*]<*num*[*i*]，时间复杂度是O(n^2)，双重for循环。
24. 最长无重复子串：滑动窗口公式：条件满足则right++，更新最大值；条件不满足则left++，直到满足为止。
25. 两数之和：使用一个HashMap记录已经遍历过的值。
26. 

