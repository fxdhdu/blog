leetcode 简单+中等 动态规划消灭。

中等104/126。  一天做3题，30天做完。一天读10题，10天读完，30天读3遍。

https://leetcode-cn.com/problemset/all/?difficulty=%E4%B8%AD%E7%AD%89&status=%E6%9C%AA%E5%81%9A&topicSlugs=dynamic-programming

[TOC]


##### 63. 不同路径 II 

题目：一个有障碍物的图，记录路径总数。

dp[0] [i] = obstacleGrid[0] [i] == 1 ? 0 : dp[0] [i-1];  第0行初始化
dp[i] [0] = obstacleGrid[i] [0] == 1 ? 0 : dp[i-1] [0];  第0列初始化
dp[i] [j] = obstacleGrid[i] [j] == 1 ? 0 : (dp[i-1] [j] + dp[i] [j-1]);  dp函数



##### 91. 解码方法

计算解码方法的总数。如果s[i]是0，则必须和s[i-1]组合，否则答案是0。

```java
        dp[0] = array[0] == '0' ? 0 : 1;
        for (int i = 1; i < n; i++) {
            if (array[i-1] == '1') {
                dp[i] = (array[i] == '0' ? 0 : dp[i-1]) + (i - 2 >= 0 ? dp[i-2] : 1);
            } else if (array[i-1] == '2' && array[i] >= '0' && array[i] <= '6') {
                dp[i] = (array[i] == '0' ? 0 : dp[i-1]) + (i - 2 >= 0 ? dp[i-2] : 1);
            } else { 
                dp[i] = array[i] == '0' ? 0 : dp[i-1];
            }
        }
```



##### 131. 分割回文串

题目：给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。

树的深度优先遍历 + 回溯保存路径 + 动态规划计算出dp数据，保存任意子串是否为回文串。



##### 198. 打家劫舍

题目：不能偷窃相邻的房屋，算偷窃的最高金额

dp[i] = Math.max(dp[i-1], dp[i-2] + num[i])

```java
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return nums[0];
        }
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
        }
        return dp[n-1];
    }
```



##### 213. 打家劫舍 II

题目：不能偷窃相邻的房屋，且房屋首位相连，算偷窃的最高金额

对于num[0...i]和num[1...i]分别进行dp[i] = Math.max(dp[i-1], dp[i-2] + num[i])计算

```java
    public int rob(int[] nums) {
        int p1 = rob(nums, 0, nums.length - 2 < 0 ? 0 : nums.length - 2); // 偷第一个房子
        int p2 = rob(nums, 1, nums.length - 1); // 不偷第一个房子
        return Math.max(p1, p2);
    }

    private int rob(int[] nums, int begin, int end) {
        if (begin  >end) {
            return 0;
        } 
        if (begin == end) {
            return nums[end];
        }

        int[] dp = new int[end + 1];
        dp[begin] = nums[begin];
        dp[begin + 1] = Math.max(nums[begin], nums[begin + 1]);
        for (int i = begin + 2; i <= end; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i-2] + nums[i]);
        }
        return dp[end];
    }
```



##### 221. 最大正方形

题目：在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

dp(i,j)为以nums(i,j)为右下角的元素，能够组成的最大正方形的边长。
dp(i,j)=0 nums(i,j)为0时
dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1
dp(i,j)=1 i和j中有一个为0，即边界情况



##### 264. 丑数 II

题目：编写一个程序，找出第 n 个丑数。丑数就是质因数只包含 2, 3, 5 的正整数。前10个丑数是：1, 2, 3, 4, 5, 6, 8, 9, 10, 12

方法一：通过最小堆计算，堆中初始化一个元素1，每次弹出堆中最小元素x，并放入x * 2，x * 3，x * 5。堆可以使用数据结构PriorityQueue，通过poll函数获取最小元素。通过一个Set记录已经计算得到的值。

方法二：通过将一个丑数乘以 2 、乘以 3、乘以 5来计算后续的丑数。用3个指针i2 i3 i5，即3个数组下标，指向当前还没乘以2、乘以3、乘以5的丑数。下一个丑数为min(nums(i2) * 2,nums(i3) * 3,nums(i5) * 5)，结果对应的i++。



##### 279. 完全平方数
题目：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。返回和为 n 的完全平方数的 最少数量 。



##### 304. 二维区域和检索 - 矩阵不可变
题目：给定一个二维矩阵，实现一个函数，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。函数签名为：public int sumRegion(int row1, int col1, int row2, int col2)



##### 309. 最佳买卖股票时机含冷冻期
题目：限制是不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票），卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。



##### 338. 比特位计数
题目：给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。



##### 357. 计算各个位数不同的数字个数
题目：给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x < 10n 。