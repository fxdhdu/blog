1. 反转链表：用循环或递归。循环时，定义3个指针pre、cur、next，不需要哨兵，结束条件是cur == null。
2. 反转链表 II（leetcode92）：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。
3. 链表中的节点每k个一组翻转(NC50)：这个题不足k个不需要翻转。和反转链表相似，实现一个函数可以反转链表a到b节点段，b节点就是a节点往前走k步所得。[如何k个一组反转链表](https://github.com/labuladong/fucking-algorithm/blob/master/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.md)
4. 链表中判断是否有环：快慢指针相遇法判断。指针先相遇表示有环，指针先为空表示无环。
5. 链表中环的入口节点：快慢指针法，相遇后再从表头派出第3个指针，与慢指针相遇点就是入口。快慢指针都从head开始跑，循环中先跑再判断是否相等。（这题快慢指针不在同一个起点会无限循环哦）
6. 两个链表的第一个公共结点（NC66）：两个链表第一个公共节点之后的链表相同，双指针法，指针第一次到达链表尾部后，换个链表继续遍历，当两个指针相遇时，就是链表公共节点。（注意点是连个指针都至少做一次交换）
7. 合并有序链表：设置一个哨兵，把两个链表中较小的节点不断往哨兵后面追加。
8. 合并k个已排序的链表(NC51、leetcode23): 实现一个合并2个已配序链表的函数，用这个函数一次合并k个链表。同样使用一个哨兵。
9. 合并两个有序的数组：A数组有足够的空间可以放下AB两个数组的元素。从A数组的末尾开始放，每次把较大的元素放过去。
10. 两个链表生成相加链表(NC40): 数字是正序存储的，高位在链表头，低位在表尾。需要反转链表后再计算，不要忘记最后的进位。
11. 两数相加（leetcode2）：两个链表相加，数字是逆序存储的，高位在链表末尾，低位在表头。返回结果生成一个新的链表。
12. 删除链表的倒数第n个节点：先走n步法，先走指针为null时则找到了。不用计算长度。但要一个pre节点。使用哨兵guard，防止链表只有一个节点，删除后就没了。