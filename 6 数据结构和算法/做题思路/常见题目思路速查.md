NC是牛客网上的题目编号。



## 链表

1. 反转链表：用循环或递归。循环时，定义3个指针pre、cur、next，不需要哨兵，结束条件是cur == null。
2. 反转链表 II（leetcode92）：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。
3. 链表中的节点每k个一组翻转(NC50)：这个题不足k个不需要翻转。和反转链表相似，实现一个函数可以反转链表a到b节点段，b节点就是a节点往前走k步所得。[如何k个一组反转链表](https://github.com/labuladong/fucking-algorithm/blob/master/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.md)
4. 链表中判断是否有环：快慢指针相遇法判断。指针先相遇表示有环，指针先为空表示无环。
5. 链表中环的入口节点：快慢指针法，相遇后再从表头派出第3个指针，与慢指针相遇点就是入口。快慢指针都从head开始跑，循环中先跑再判断是否相等。（这题快慢指针不在同一个起点会无限循环哦）
6. 两个链表的第一个公共结点（NC66）：两个链表第一个公共节点之后的链表相同，双指针法，指针第一次到达链表尾部后，换个链表继续遍历，当两个指针相遇时，就是链表公共节点。（注意点是连个指针都至少做一次交换）
7. 合并有序链表：设置一个哨兵，把两个链表中较小的节点不断往哨兵后面追加。
8. 合并k个已排序的链表(NC51、leetcode23): 实现一个合并2个已配序链表的函数，用这个函数一次合并k个链表。同样使用一个哨兵。
9. 合并两个有序的数组：A数组有足够的空间可以放下AB两个数组的元素。从A数组的末尾开始放，每次把较大的元素放过去。
10. 两个链表生成相加链表(NC40): 数字是正序存储的，高位在链表头，低位在表尾。需要反转链表后再计算，不要忘记最后的进位。
11. 两数相加（leetcode2）：两个链表相加，数字是逆序存储的，高位在链表末尾，低位在表头。返回结果生成一个新的链表。
12. 删除链表的倒数第n个节点：先走n步法，先走指针为null时则找到了。不用计算长度。但要一个pre节点。使用哨兵guard，防止链表只有一个节点，删除后就没了。

## 树

1. 实现二叉树先序，中序和后序遍历
2. 求二叉树的层序遍历：队列
3. 二叉树的之字形层序遍历（NC14）/二叉树的锯齿形层序遍历（leetcode103）：使用两个栈，从左往右遍历时，先放入左子树，从右往左遍历时，先放入右子树。
4. **最近公共祖先（NC102）**：返回二叉树中两个节点的最近公共祖先节点。后根序遍历，这样可以保证最近（即深度最大）。2中方法：1.递归函数返回找到的o1或o2的个数。 2.递归函数返回o1/o2或答案。
5. 二叉搜索树的最近公共祖先（leetcode235）：由于是二叉搜索树，所以比二叉树的情况下更简单。答案在左子树？答案在右子树？否则当前节点就是答案。
6. 重建二叉树（NC12）：根据前序遍历和中序遍历，重建二叉树。找根节点，然后分别递归重建左右子树。
7. 树的子结构（Leetcode Offer 26）：判断树B是否是树A的子结构。第一个函数HasSubtree() 用作外部递归函数。第二个函数DoesTree1HaveTree2()作为内部递归函数。HasSubtree中先判断两个根节点是否相等，相等则调用DoesTree1HaveTree2，否则左右子树递归调用HasSubtree。
8. 判断二叉树是否对称（NC16、leetcode offer 28、leetcode 101）：递归和迭代实现。递归函数是判断两个子树是否为镜像。isMirror(TreeNode left, TreeNode right)，left和right值相等，left的左子树和right的右子树互为镜像，left的右子树和right的左子树互为镜像。

## 其他数据结构

1. 用两个栈实现队列：一个栈进元素，一个栈出元素。



## 动态规划

1. 跳台阶：一次上一级或二级台阶，问有几种上法。dp[n] = dp[n-1] + dp[n-2]
2. 子数组的最大累加和问题：dp[i] 为以i元素结束的这个数组的子数组的最大累加和。dp = Math.max(dp + arr[i], arr[i]); 并记录最大值。
3. **最长公共子串：计算两个字符串的最长公共子串。**dp[i] [j] 的含义是：以s1[i]和s2[j] 为最后一个元素的最长公共子串。dp[i] [j] = dp[i-1] [j-1] + 1 ，s1[i] == s2[j]时；dp[i] [j] = 0，s1[i] ！= s2[j]时
4. 最长公共子序列（leetcode1143）  ：返回这两个字符串的最长公共子序列的长度。dp[i] [j] 的含义是：对于 s1[1..i] 和 s2[1..j]，它们的最长公共子序列的长度是dp[i] [j]。dp[i] [j] = dp[i-1] [j-1] + 1 ，str1[i - 1] == str2[j - 1]时；dp[i] [j] = Math.max(dp[i-1] [j], dp[i] [j-1]) , 其他。
5. **最长递增子序列（leetcode300）**：子序列不用连续。需要输出字典序最小的子序列。定义 dp[i] 为考虑前 i 个元素，以第 i个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。 *dp*[*i*]=max(*dp*[*j*])+1, 其中0≤*j*<*i*且*num*[*j*]<*num*[*i*]，时间复杂度是O(n^2)，双重for循环。
6. **最长递增子序列的个数（leetcode673）**
7. 最长递增子序列（NC91）：NC91比leetcode300难度高，这题需要输出子序列，且子序列有多个时，需要字典序最小的。
8. **最长回文子串（NC17 、leetcode5）**：dp[i] [j]  s[i..j] 是否是回文串。 i==j时，字符串长度为1，dp[i] [j] = true; j = i + 1时，字符串长度为2，两个字符相等则为回文。字符串长度>=3时，dp[i] [j] = dp[i+1] [j-1]  && s[i] == s[j]
9. 买卖股票的最好时机（NC7）：只能一次买入和卖出。最简单就是双重for循环穷举结果，时间复杂度是O(n^2)。动态规划思路是：维护一个当前日期前的股票最低价minBefore，这样当前节点卖出的最大收益就是dp[i] = prices[i] - minBefore;
10. 矩阵的最小路径和（NC59）



1. 最长无重复子串：滑动窗口公式：条件满足则right++，更新最大值；条件不满足则left++，直到满足为止。
2. 两数之和（leetcode1）：一次遍历，时间复杂度O(n)。使用一个HashMap记录已经遍历过的值及其下标。
3. 括号序列：判断给出的字符串是否是合法的括号序列。遇到匹配的则pop，否则就push，最后判断stack是否为空。
4. 快速排序：递归，非递归实现。（pivot、partition、swap）
5. **最小的K个数**：快排，找出pivot后直接返回？
6. 寻找第K大：快排，找出pivot后直接返回。
7. 二分查找。（求mid再判断区间）
8. **设计LRU缓存结构：**
   1. 继承LinkedHashMap（太简单，不符合面试要求），覆盖removeEldestEntry方法。
   2. 不继承LinkedHashMap实现，同时要自定义链表结构。使用HashMap + 自定义结构的双向链表。双向链表实现头部插入/尾部删除/移动节点到头部等方法。双向链表头尾节点使用两个哨兵。（是否可以使用linkedlist？）
9. 大数加法(NC1)：两个字符串数字相加，返回字符串。
10. 反转字符串(NC103)
11. 求平方根（NC32）：计算并返回x的平方根（向下取整），可以用二分查找。
12. 螺旋矩阵（NC38、leetcode54）：按螺旋的顺序返回矩阵中的所有元素。思路简单实现容易出错。用四个边界指针，每遍历完一个边，边界指针相应收缩。

