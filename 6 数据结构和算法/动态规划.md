[TOC]



## 动态规划问题性质

### 重叠子问题

备忘录：自顶向下

DP table：自底向上

### 最优子结构

- 要符合「最优子结构」，子问题间必须互相独立。
- 可以从子问题的最优结果推出更大规模问题的最优结果。


### 状态转移方程











## 如何列出正确的状态转移方程

1. 先确定「状态」
2. 然后确定 `dp` 函数的定义
3. 然后确定「选择」并择优



## 动态规划设计流程

动态规划的核心设计思想：数学归纳。

> 比如我们想证明一个数学结论，那么我们先假设这个结论在 `k 时成立，然后想办法证明 `k=n` 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。
>
> 类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 `dp[0...i-1]` 都已经被算出来了，然后问自己：怎么通过这些结果算出 dp[i]？

1. 状态和选择

2. 明确 dp 数组所存数据的含义

3. 根据 dp 数组的定义，运用数学归纳法的思想，假设 `dp[0...i-1]` 都已知，想办法求出 `dp[i]`

  但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。

  例如：[300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)。如果d p[n] 仅仅表示子序列 0 ～ n的最大递增子序列的长度，则通过dp[n - 1]无法得到dp[n]，因为不知道nums[n] 是否比dp[n-1]所表示的最大子序列的最大元素大。所以此题中，dp[n]表示以nu ms[n]结尾的最大递增子序列的长度。 最总结果为dp[n]数组的最大值。

4. 问题的 base case 是什么，以此来初始化 dp 数组，以保证算法正确运行



## 题目

### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

dp[n] 总金额为n时的最少硬币个数。  

n < 0, -1

n = 0,    0

n = 1 2 5, 1

dp[n] = dp [n - coins[i]] + 1



### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)



### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)



### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

状态：可选择的数字、已选择的数字总数（当前 背包容量）

选择：数字进入第二数组，或则留在第一数组



dp[i] [j]  对于前i个元素，已选择数字的总数。 数组存放boolean值(答案为boolean值)，表示是否能装到此容量。

base case：dp[0] [] = false, dp[] [0] = true

Ans; dp[n] [sum / 2]



d p[i] [j] = dp[i - 1] [j - 遍历值]  | dp[i - 1] [j]





