## 常见场景

### 8皇后问题

### 0-1背包问题

### 正则表达式匹配

### 解决广义的搜索问题





|                                                              |      |                                                              |
| ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/) |      | 1)用减法可以减少一个递归函数参数target<br>2)递归结束条件：递归树的叶子节点，<br/>3)向上剪枝，直接退出循环 |
| [79. 单词搜索](https://leetcode-cn.com/problems/word-search/) |      | 1)第一个双重循环用来初始化起点<br>2)循环中的函数才进行递归。 |
| [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/) |      | 1) 排序以后剪枝，剪枝可以直接去除重复排列，并提高效率。<br>2）使用Set消除重复排列。<br>3）画出递归树找出重复递归分支。 |
| [46. 全排列](https://leetcode-cn.com/problems/permutations/) |      | 1）深度优先遍历递归树，dfs。<br>2）栈推荐使用Deque< Integer > stack = new ArrayDeque< Integer >();方式初始化 |
| [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/) |      | 思想，把所有元素都交换到位置0一次，如果某个元素已经放置过位置0，则剪枝跳过。依次处理后面的数组。 |



```java
主循环：
for (int i = 0; i < board.length; i++) {
  for (int j = 0; j < board[0].length; j++) {
    exist(board, board.length, board[0].length, i, j, 0, word); // 递归
  }
}
```

