| 题目                                                         | 一句话描述                                   | 套路                                                         |
| ------------------------------------------------------------ | -------------------------------------------- | ------------------------------------------------------------ |
| [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/) | 两个链表相加                                 | 遍历                                                         |
| [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/) |                                              | 1）迭代法：链表互换，在链表1中找到缺口，将链表2符合条件的部分插入。 2）递归法 3)迭代法：新的链表用一个哨兵preHead。 |
| [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) |                                              | 遍历；递归                                                   |
| [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/) | 反转链表的中间部分                           | 一趟遍历；0) 不用处理的场景 1）实现一般场景 2）处理特殊场景  |
| [146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/) | 最久未使用先抛弃                             |                                                              |
| [460. LFU缓存](https://leetcode-cn.com/problems/lfu-cache/)  | 最少使用先抛弃，使用频率相同则抛弃最久未使用 | 二叉平衡数最左边的节点。使用TreeSet                          |
| [面试题22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/) | 输出链表倒数第K个节点值                      | 先行指针。                                                   |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |



先进先出策略 FIFO（First In，First Out）

最少使用策略 LFU（Least Frequently Used）

最近最少使用策略 LRU（Least Recently Used）



维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。





## 技巧

链表数组哨兵

链表插入2步骤：先连接next