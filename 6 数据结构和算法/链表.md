| 题目                                                         | 一句话描述                                   | 套路                                                         |
| ------------------------------------------------------------ | -------------------------------------------- | ------------------------------------------------------------ |
| [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/) | 两个链表相加                                 | 遍历                                                         |
| [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/) |                                              | 可以用堆栈，不要忘记处理进位。                               |
| [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/) |                                              | 1）迭代法：链表互换，在链表1中找到缺口，将链表2符合条件的部分插入。 2）递归法 3)迭代法：新的链表用一个哨兵preHead。 |
| [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) |                                              | 遍历（用3个指针：前驱节点、当前节点、临时节点；当前节点从head开始；入口可以没有空校验）；<br/>递归（把当前节点拆下来，把后续链表反转后拼接上当前节点） |
| [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/) | 反转链表的中间部分                           | 一趟遍历；0) 不用处理的场景 1）实现一般场景 2）处理特殊场景  |
| [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/) |                                              | 1. 取K个元素进行反转；保留头节点作为返回值；保留尾节点。<br/>2. 递归反转剩下的链表。<br/>3. 最后不满足k个元素的链表保持不变。（先判断元素个数再反转） |
| [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/) |                                              | K个一组的特殊形式。                                          |
| [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/) |                                              | 堆栈法                                                       |
| [146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/) | 最久未使用先抛弃                             |                                                              |
| [460. LFU缓存](https://leetcode-cn.com/problems/lfu-cache/)  | 最少使用先抛弃，使用频率相同则抛弃最久未使用 | 二叉平衡数最左边的节点。使用TreeSet                          |
| [面试题22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/) | 输出链表倒数第K个节点值                      | 先行指针。                                                   |
| [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/) | 找环形链表的入口                             | 1）用Set存储<br>2）快慢指针法，相遇后再从表头派出第3个指针，与慢指针相遇点就是入口。<br>**两种方法均不需要在函数入口判断null，直接在循环体中判null** |
| [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/) |                                              | 我想到的方法：先计算链表长度，k对长度取模，然后用快慢指针的方式。<br>官方方法：先把链表首位相连，变成一个循环链表，同时计算链表长度。然后找到新的尾节点，把链表断开。 |
| [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/) |                                              | 1)使用dummy哨兵 2）链表插入：两步法，先操作当前指针指向next，然后前指针指向当前指针。 3）head为null或head.next为null通常可以直接返回 |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |
|                                                              |                                              |                                                              |



先进先出策略 FIFO（First In，First Out）

最少使用策略 LFU（Least Frequently Used）

最近最少使用策略 LRU（Least Recently Used）



维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。





## 通用技巧

1. 链表数组哨兵
2. 链表插入2步骤：先连接next
3. 用3个指针：前驱节点、当前节点、临时节点