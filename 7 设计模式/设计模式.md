[TOC]



## 创建型

### 单例模式

#### 应用场景

线程池

缓存（系统配置）

注册表

日志Logger对象：防止竞争

唯一递增 ID 号码生成器



#### 实现方式

构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；

考虑对象创建时的线程安全问题；

考虑是否支持延迟加载；

考虑 getInstance() 性能是否高（是否加锁）。

##### 饿汉模式

1. 私有静态实例（private statis），直接实例化（new）。（类加载时实例化，浪费空间，但却线程安全）
2. 私有构造函数（private）
3. 公共静态方法获取实例，直接返回实例（public static getInstance）。

优点：线程安全。（两个线程同时获取实例，肯定是类加载时实例化的实例）

缺点：浪费空间

##### 懒汉式

1. 私有静态实例（private statis）
2. 私有构造函数（private）
3. 公共静态方法获取实例（public static getInstance），先判断实例是否为null，为null则需要实例化。（延迟实例化，非线程安全）
   1. synchronized保证线程安全，但性能下降，会造成线程阻塞。

##### 双重检测

Volatile 类型的实例，防止指令重排序，导致刚刚被new出来，但是还没初始化的实例被其他线程使用。

##### 静态内部类

```java

public class IdGenerator { 
  private AtomicLong id = new AtomicLong(0);
  private IdGenerator() {}

  private static class SingletonHolder{ //静态内部类
    private static final IdGenerator instance = new IdGenerator();
  }
  
  public static IdGenerator getInstance() {
    return SingletonHolder.instance; // 初始化静态内部类。由JVM保证了，唯一性/线程安全/延迟加载。
  }
 
  public long getId() { 
    return id.incrementAndGet();
  }
}
```

##### 枚举



1. 如何在反射的情况下保证单例？ 为了防止通过反射的方式调用构造函数，需要对构造函数进行修改，使其只允许调用一次，多次调用则抛错。
2. 如何在反序列化中保证单例？

#### 参考

[月薪5万程序员眼中的单例模式](https://mp.weixin.qq.com/s/WRYj-pIgQ85VVXmGcFmaLA)







### 工厂模式

简单工厂、静态工厂：封装创建对象的代码到一个Factory类，客户端引用Factory类来创建对象。创建对象的方法通常为声明static。不能通过继承来改变创建方法的行为。

工厂方法：工厂方法是个抽象的方法（abstract、interface），将创建对象的行为封装在子类中，客户代码只对超类做处理，使实例化具体类的代码从客户代码中抽离出来。（对扩展开放，对修改关闭：）



#### 参考

[关于 Java 的静态工厂方法，看这一篇就够了！](https://www.jianshu.com/p/ceb5ec8f1174)

### 建造者模式



### 原型模式

JavaScript 是一种基于原型的面向对象编程语言。

#### 应用场景



#### 实现方式

##### 深拷贝

1. 递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。
2. 先将对象序列化，然后再反序列化成新的对象。

##### 浅拷贝

只复制索引，不复制索引指向的对象本身。



## 结构型

### 装饰器模式



### 外观模式（Facade模式）

[外观模式](http://www.runoob.com/design-pattern/facade-pattern.html)

作用：隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。

结构型模式

应用实例：

1、JAVA 的三层开发模式。

2、医院的接待员，帮忙处理挂号、门诊、划价、取药等步骤。

3、电脑整机，只要按下电源键，就能对CPU、内存、硬盘等一系列设备进行处理。

## 行为型

### 责任链模式（Chain of Responsibility Pattern）


 为**请求**创建了一个**接收者**对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于**行为型模式**。

在这种模式中，通常**每个接收者都包含对另一个接收者的引用**。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

**特点**

有一个set方法，用于设置下一个拦截器。

**应用**

1、activiti中使用了职责链模式，构造了命令拦截器链，用于在命令真正被执行之前做一系列操作。

CommandInterceptor

AbstractCommandInterceptor

LogInterceptor

2、spring aop 拦截器

参考

[责任链模式](http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html)