[TOC]

## 参考

[高性能MySQL](https://book.douban.com/subject/23008813/)

http://blog.codinglabs.org/articles/theory-of-mysql-index.html

https://blog.csdn.net/xluren/article/details/32746183

[05 | 深入浅出索引（下）](https://time.geekbang.org/column/article/69636)

[拜托，别再问我什么是B+树 了](https://mp.weixin.qq.com/s/svL_yNmNJ-wj9aGjtO_Yww)




## 索引基础

索引是帮助MySQL高效获取数据的数据结构。不使用索引时，查找数据时会进行全表扫描。添加索引后能够减少查询时的遍历，降低每次查找数据时，磁盘IO的数目，把磁盘IO的次数控制在一个很小的数量级，提高Mysql的检索速度。查询算法只能应用于特定的数据结构上，数据库维护着满足特定查询算法的数据结构。索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。索引的实现和存储引擎相关，各存储引擎对索引支持各不相同。

- 索引的缺点
    - 索引会降低更新表的速度（INSERT、UPDATE、DELETE）。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。
    - 索引文件会占用磁盘空间。
- MyISAM，索引文件和数据文件分离(非聚集)，索引文件保存在磁盘上，仅仅保存数据记录的地址。
- InnoDB，叶子结点保存了完整的数据记录（聚集索引）。数据文件本身按主键聚集。

## 索引分类

单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。

普通索引

唯一索引

主键索引：要求key是唯一的

组合索引：索引包含多个列

### 覆盖索引

通过覆盖索引，避免回表，减少树的搜索次数。但会增加索引字段维护开销。

### 聚簇索引

在叶子结点存放一整行记录的索引。

### 非聚簇索引

其他索引



## MySQL中的索引类型



### B-Tree（BTREE/B树）

B树是一种平衡搜索树。它设计用于磁盘或其他直接存取的辅助存储设备，可以降低磁盘I/O操作数。

一颗B树具有以下性质

1. 每个节点包含属性	
   1. 当前节点中关键字个数n （在设计时，考虑磁盘页大小）
   2. n个非降序存放的关键字（索引）本身（key1，key2，key3 ... keyn）
   3. n+1个指向孩子的指针（n个关键字对存储在子树中的关键字分为n+1个区间）
   4. 叶节点标识，用来表示节点是否为叶子节点（类似Multitask任务结构）
2. 每个叶子节点深度相同
3. 每个叶子节点所包含的关键字个数存在上下界，称为B树的最小度数t。除根节点以外，每个节点至少有t个子节点，至多有2t个子节点，

B+树把所有的卫星数据都存储在叶节点中，内部节点只存放关键字和孩子指针，最大化内部节点的分支因子。而B 树中的节点存储卫星数据。

B树使用最多。叶子节点并不需要链表来串联。

### B+Tree

B+Tree索引需要解决的问题有1）精确查找 2）区间查找 3）顺序查找、逆序查找。

B+树从平衡二叉树演化而来，它是一颗平衡的N叉树，树节点用于存储索引值，叶子结点通过前后相连形成一个双向链表存储行记录。B+树根节点存放在内存里。

提高区间访问的性能。（与跳表非常相似，从二叉查找树演化而来）通过设计为多叉查找树，降低树的高度，将叶子结点串联成一个链表以支持区间查询。B+ 树中的节点不存储数据，只是存储索引。

#### B+Tree的结构

![img](./assert/ea4472fd7bb7fa948532c8c8ba334430.png)

#### B+Tree的特点

- 每个节点中子节点的个数不能超过 m，也不能小于 m/2；

- 根节点的子节点个数可以不超过 m/2，这是一个例外；

- m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；

- 通过链表将叶子节点串联在一起，这样可以方便按区间查找；

- 一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。



数据插入时，节点的子节点个数>N时，进行页分裂。

数据删除时，节点的子节点个数<N/2时，进行页合并。

使用主键（ID）索引可以减少页分裂，因为新增主键一般比所有已有的值要大，不会随机插入树中间。



页读取、预读、局部性原理

#### 最左前缀原则

- 在查询的where条件中，联合索引（包括退化的单列索引），在索引匹配时，只有存在最左前缀作为查询的条件时（从最左边开始的前缀），后面的索引才会生效。
- 范围查询时，只有第一列索引才生效。
- 最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。

索引匹配的最左原则具体是说，假如索引列分别为A，B，C，顺序也是A，B，C：

1. 那么查询的时候，如果查询【A】【A，B】 【A，B，C】，那么可以通过索引查询
2. 如果查询的时候，采用【A，C】，那么C这个虽然是索引，但是由于中间缺失了B，因此C这个索引是用不到的，只能用到A索引
3. 如果查询的时候，采用【B】 【B，C】 【C】，由于没有用到第一列索引，不是最左前缀，那么后面的索引也是用不到了
4. 如果查询的时候，采用范围查询，并且是最左前缀，也就是第一列索引，那么可以用到索引，但是范围后面的列无法用到索引

### 哈希索引（HASH）

哈希索引存储的是被索引字段值的哈希值，只支持**等值查询**（精确匹配）。哈希索引特别适用于**字段值非常长**的场景。这种场景不适合使用B-Tree索引，因为B-Tree一个PAGE至少要存储3个ENTRY，所以不支持特别长的字段值。当字段值为很长的字符串，并且用户只需要等值搜索，建议使用哈希索引。

### RTREE

### 全文索引（FULLTEXT）

## Postgresql的索引类型

- BTREE

  - 索引字段长度超过1/3索引页的大小，创建索引时会报错。
  - 技术上是B+树结构
  - High Key：B+树的每一个节点都有一个High-Key值，此值表示此节点或者此节点的子节点的最大值。

- 哈希索引（HASH）

Postgresql添加索引

  - sql语法参考：https://www.postgresql.org/docs/current/sql-createindex.html
  - 当不指定索引方法时，默认为BTREE。其他包括哈希索引、全文索引等。

  

## 实践

### 选择需要添加索引的列

- 查询条件下出现的列  (一般作为 WHERE 子句的条件)。
- B+树索引添加在高选择性的列（名字）合适，低选择性（性别）的列不合适。
- 更新频繁的列不宜添加索引
![ScreenClip](.\assert\ScreenClip.png)

### 避免索引失效

- 不满足最左前缀原则时
- 索引列不包含在where查询条件中
- 在索引列上使用函数或进行运算也会使索引失效。可以将计算放到业务层。
- 负向条件不支持索引。!=、 <>、 not in、 not exist、 not like
- 索引最多用于一个范围列，范围列后的列索引失效