## 参考

[MySQL事务的实现原理](https://mp.weixin.qq.com/s/J_UQsL5Xz5akFVgSAo272Q)

[MySQL的Binlog与Redolog](https://www.jianshu.com/p/65eb0526bfc0)

[Mysql面试题系列-什么是crash-safe能力？什么是两阶段提交？](https://zhuanlan.zhihu.com/p/157893102)

MySQL最重要、最与众不同的特性是它的存储引擎架构：将查询处理及其他系统任务和数据的存储/提取相分离。（处理和存储分离）可以为每张表选择合适的存储引擎。事务型表（InnoDB）和非事务型表（MyISAM）



MySQL服务器3层逻辑架构图：连接层、服务器层、存储引擎层。服务层：MySQL的核心服务功能，包括查询语句解析，词法语法分析，优化，缓存以及内置函数(日期，时间，数学，加密等)，跨存储引擎的功能：存储过程，触发器，视图等。引擎层负责MySQL中数据的存储和提取。



## 事务的ACID特性，及其实现原理

- A：原子性(Atomicity)：undo log回滚日志，记录数据被修改前的信息，发生错误或者rollback操作时回滚之前的操作。保障未提交事务的原子性。事务开始后，每次数据变更都伴随着undo log的产生，undo log先于数据持久化到磁盘上。
- C：一致性(Consistency)：
- I：隔离性(Isolation)：通过读写锁和MVCC来实现的，MVCC又依赖undo log和read view
- D：持久性(Durability)：redo log重做日志，记录数据被修改后的信息，用来恢复数据（crash-safe能力），保障已提交事务的持久性，重做日志缓冲redo log buffer + 重做日志文件redo log，后台线程做缓存磁盘间同步。mysql表数据存在磁盘上，innodb为了提升性能提供了缓存池buffer pool，读数据先读缓存，没有则从数据库读后放入磁盘。写输入先写缓存，缓存定期同步到磁盘。redo log顺序存储，I/O效率高，缓存同步是随机I/O 效率很低。修改表数据时只修改内存，修改行为记录到磁盘上的事务日志，事务日志采用追加方式（顺序I/O：顺序I/O是加快机械磁盘读取的方法,sui）

innodb 通过 redo log 和 undo log 来实现crash-safe

## SQL标准中定义的四种事务隔离级别，及其实现原理

隔离级别规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。是数据可靠性和性能之间的权衡。

- read uncommitted（未提交读/读未提交）：一个事务还没提交时，它做的变更就能被别的事务看到，即事务总是读取最新的行。会产生脏读，即读取到未提交的数据，很少使用的一种隔离级别。
- Read committed（提交读）：一个事务提交之后，它做的变更才会被其他事务看到。解决了脏读问题，但还是会出现不可重复读和幻读，不可重复读即读取其他事务已提交的数据，导致同一个事务中前后两次相同查询的结果不同。
- repeatable read（可重复读）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。可能会有幻读，即A事务读取B事务提交的新增数据，修改的已提交数据不会被读到，新增数据就像一个幻像。InnoDB通过多MVCC解决幻读问题，是MySQL默认事务隔离级别
- Serializable（可串行化）：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。会对所有读取的行都加锁。

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

## binlog日志

server层的binlog（归档日志）主要用来做主从复制和数据库恢复。

**binlog和Redo Log主要有以下三点不同:**

Redo Log是InnoDB引擎特有的；binlog是MySQL的server层实现的，不管哪种引擎，都会有binlog。 

Redo Log是物理日志，记录数据是怎么变化的；binlog是逻辑日志，记录的是语句的逻辑操作。 

Redo Log是循环写的，空间固定会用完（什么是循环写呢？事务提交时，会先写到redo log里面去，当写完一个事务时，write pos会往前移动，在redo log中的记录被更新到数据库中时，checkpoint 会往前移动。）；binlog是追加写入的，文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

**怎么保证binlog和redolog的一致性：**

假设redo log和binlog分别提交，可能会造成用日志恢复出来的数据和原来数据不一致的情况。

两阶段提交保证，redo log 有prepare和commit两个阶段

## 复制技术

![img](./assert/1287410-20200208193558291-1552322385.png)

如上图所示，在主从复制中，更新语句会记录 binlog，前面我们说过它是一种逻辑日志。有了这个 binlog，从服务器会获取主服务器的 binlog 文件，然后解析里面的 SQL语句，在从服务器上面执行一遍，保持主从的数据一致。这里面涉及到三个线程，连接到 master 获取 binlog，并且解析 binlog 写入中继日志，这个线程叫做 I/O 线程；Master 节点上有一个 log dump 线程，是用来发送 binlog 给 slave 的；从库的 SQL 线程，是用来读取 relay log，把数据写入到数据库的。 如果数据库做了主从复制后，我们只需要把数据写入主节点，而从节点分担读的请求，这种方法我们也可以叫做读写分离。读写分离可以一定程度低减轻数据库服务器的访问压力，但是需要特别注意主从数据一致性的问题。如果我们在 主节点写入了，马上到 从节点 查询，而这个时候 从节点 的数据还没有同步过来，就会导致查询的数据偏差

## WAL技术(Write-Ahead Logging)

在更新数据时，先写日志，再写内存，就是所谓的WAL技术(Write-Ahead Logging)，内存中的数据异步同步到磁盘上。

## MySql锁技术

[Mysql数据库锁之---表级锁、行级锁、悲观锁、乐观锁、间隙锁GAP、死锁等简单介绍](https://blog.csdn.net/With_Her/article/details/81535813)

mysql使用读写锁组合来对读写请求进行控制，读锁又称共享锁，多个读请求可共享一把锁读数据而不阻塞。写锁又称排他锁，写锁与其他所有锁请求互斥。



从锁粒度分为：行级锁，表级锁

间隙锁:当我们**用范围条件检索数据，**并请求共享或排他锁时，InnoDB会给**符合范围条件的已有数据记录的索引项加锁**；

**对于键值在条件范围内但并不存在的记录**，叫做“**间隙**（GAP)”。InnoDB也会对这个“**间隙**”加锁.注意！间隙锁只能在Repeatable read隔离级别下使用。目的是为了防止幻读。

乐观锁，悲观锁（select * from x x x for update）

## 多版本并发控制（MVCC）

不同引擎不同的数据库（Oracle、PostgreSQL有不同的实现机制），避免加锁降低开销。常见实现方式有乐观并发控制、悲观并发控制。

InnoDB的实现：在每行记录后面保存行的创建时间和行的过期时间（删除时间），即系统版本号。每开始一个事务系统版本号递增，并作为事务的版本号。（类似于事务ID设计）

mysql中mvcc实现依赖undo log 与read view，undo log中记录某行数据的多个版本，read view用来判断当前版本数据的可见性。

mvcc不同于乐观锁，乐观锁通过cas实现，mvcc是基于快照的无锁隔离机制。

![image-20200803075849587](/Users/fanxudong/IdeaProjects/blog/10 分布式系统设计/asset/image-20200803075849587.png)

