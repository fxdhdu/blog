[TOC]

## 学习网站

| 项目 | 说明 |
| ----------------------------------------------- | ------------------------------------------------------------ |
| https://www.python.org/                         | Python 官网，时常关注，保持更新。当前最新版本 Python 3.10.0，2.7。 |
| https://docs.python.org/dev/tutorial/index.html | 教程，用户手册。                                             |
| 《Python 基础教程》 附录 B                         | Python 参考手册。表达式、语句等。                            |

## 基础知识

### 基本用法

1. 整除： 1 // 2
2. 取余：10 % 3    2.75 % 0.5
3. 幂（乘方）： 2 ** 3
4. 长整数：
5. from \_\_future\_\_ import division
6. import：导入模块。 from 模块 import 函数：可直接使用函数，不用模块名做前缀。
7. \：字符串中转义。普通字符串换行，其实就是转义了最后的换行符。
8.  """：长字符串
9.  \_\_call\_\_ 定义类型的时候实现此方法，使类型成为可调用的

### 基本数据类型

从底层数据结构，访问算法复杂度分析这些数据类型

#### 不可变数据类型

不可变数据类型在创建之后，其值不能被修改。如果对不可变数据类型进行修改操作，实际上是创建了一个新的对象。例如：但当执行``` num = num + 1 ```时，创建了一个新的整数对象， num 指向了这个新对象。


- **number**：Python 中的数字类型（如整数、浮点数等）通常在内存中以固定的格式存储。例如，整数类型根据其大小可能会占用不同的字节数。
- **string**：字符串是由字符组成的不可变序列，存储在内存中的连续区域。每个字符通常占用一个或多个字节，具体取决于编码方式。
- **tuple**：元组是由多个元素组成的不可变序列，其元素可以是不同的数据类型。元组在内存中以连续的方式存储，每个元素的内存地址是固定的。
  
#### 可变数据类型

可变数据类型在创建之后，其值可以被修改。对可变数据类型进行修改操作时，不会创建新的对象，而是直接在原对象上进行修改。

- **list**：列表是由多个元素组成的可变序列，其元素可以是不同的数据类型。列表在内存中以动态数组的方式存储，当列表的元素数量发生变化时，会自动调整内存空间。
- - 列表的切片操作
- **dict**：字典是由键值对组成的可变集合，键必须是不可变数据类型（如字符串、数字、元组等），值可以是任意数据类型。字典在内存中以哈希表的方式存储，通过键的哈希值来快速定位对应的值。
- - 在Python 3.5（含）以前，字典是不能保证顺序的，但是从Python 3.6开始，字典是变成有顺序的了
- **set**：集合是由唯一元素组成的可变集合，元素必须是不可变数据类型。集合在内存中以哈希表的方式存储，通过元素的哈希值来快速判断元素是否存在。

### 函数

#### *args和**kwargs

函数定义参数时 function(*args, **kwargs), *args, **kwargs 表示不定数量参数（实参）。
- *args 表示非键值对的可变参数列表，传入的多个参数将按照元组的形式存储，是一个元组；
- \**kwargs表示不定数量的键值对参数列表，传入的(多个)参数将按照字典的形式存储，是一个字典。

使用：
- *args 和 \**kwargs可以同时在函数的定义中，*args必须在**kwargs前面。
- 使用 args 和 kwargs 作为参数名只是举例，可以任意替换。

- 如果我们不知道将多少个参数传递给函数，比如当我们想传递一个列表或一个元组值时，就可以使用*args
- 当我们不知道将会传入多少关键字参数时，使用**kwargs 会收集关键字参数


[python中的*args和**kwargs用法解读](https://juejin.cn/post/6991433488930963486)

#### 函数参数是值传递还是引用传递？

https://www.cnblogs.com/loleina/p/5276918.html 

值传递（passl-by-value）过程中，被调函数的形式参数作为被调函数的局部变量处理，即在堆栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。

　　引用传递(pass-by-reference)过程中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。


本质上既不是值传递也不是引用传递，传递的是"对象地址”；需要分可变对象和不可变对象。

python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值'来传递对象。


### 装饰器

装饰器可以修改或增强函数或方法的行为，而不需要修改它们的源代码。装饰器本质上是一个函数，它接受一个函数作为参数，并返回一个新的函数。
使用装饰器的步骤如下：定义一个装饰器函数，它接受一个函数作为参数，并返回一个新的函数。在要装饰的函数前面加上装饰器函数的注解（@decorator_name）。

用途：
常用于切面需求的场景，比如:插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器可以抽离出大量与函数功能本身无关的雷同代码并继续重用。 


https://www.cnblogs.com/cicaday/p/python-decorator.html


Python中常用的内置的装饰器:
- @staticmethod：用于将方法声明为静态方法，该方法属于类而不是实例。
- @classmethod：用于将方法声明为类方法，该方法可以访问类级别的属性和方法。
- @property：用于将方法声明为属性，可以像访问属性一样调用它，而不需要添加()。
- @abstractmethod：用于声明抽象方法，要求子类实现该方法。
- @final：用于声明方法或类为最终版本，不能被子类继承或覆盖。
- @lru_cache：用于缓存函数的结果，以提高函数调用的性能。
- @wraps：用于保留原始函数的元数据，如文档字符串和函数名。


实现一个重试装饰器
```python
import time

def retry(max_attempts, delay=1):
    def decorator(func):
        def wrapper(*args, **kwargs):
            attempts = 0
            while attempts < max_attempts:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    attempts += 1
                    if attempts < max_attempts:
                        print(f"尝试失败，第 {attempts} 次，等待 {delay} 秒后重试...")
                        time.sleep(delay)
            print("达到最大尝试次数，放弃重试。")
        return wrapper
    return decorator

@retry(max_attempts=3, delay=2)
def fragile_function():
    import random
    if random.random() < 0.7:
        raise ValueError("模拟失败")
    return "成功"

print(fragile_function())
```


### 深拷贝和浅拷贝

直接赋值（=）：不是浅拷贝也不是深拷贝，是新建了一个对象的引用（别名）。
浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。
深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。

[python深拷贝和浅拷贝详解](https://www.jianshu.com/p/7f9a0588499b)

浅拷贝示例：
```python
a={"key":1}
b=a  # 直接赋值，b相当于a的别名，引用。
b["key"]=2 
print b  # {"key":2}
print a  # {"key":2}
```

深拷贝示例：
使用copy.deepcopy达到深拷贝的目的
```python
import copy 
a= {"key":1} 
b=copy.deepcopy(a) 
b["key"]=2 
print b 
print a
```

深拷贝时如何解决循环引用的问题?
```copy.deepcopy``` 函数在内部维护了一个备忘录（memo），这是一个字典，用于记录已经拷贝过的对象。在深拷贝过程中，每当遇到一个对象，它会先检查该对象是否已经在备忘录中。如果存在，就直接返回备忘录中对应的拷贝对象，而不是再次进行拷贝，从而避免了循环引用导致的无限递归。


### lambda表达式

用lambda表达式定义一个功能简单的函数（两数乘积）

```python
sum=lambda a, b: a * b
sum(3,5)
```

### \_\_new\_\_和__init__方法

__new__创建对象实例
__init__初始化对象实例

利用__new__实现一个单例模式的类:
```python
class Singleton(object): 
  def __new__(cls, *args,**kwargs):
    obj = getattr(cls, "__obj", None)
    if obj is None: 
        obj = object.__new__(cls, *args,**kwargs)
        setattr(cls,"__obj", obj) 
    return obj

def main(): 
    O1 = Singleton() 
    O2 = Singleton()
    print(O1 == O2)

if __name__ == "__main__": 
    main()
```

### 闭包 UnboundLocalError

在 Python 里，闭包（Closure）允许一个函数访问并操作其外部函数作用域中的变量，即便外部函数已经执行完毕。

要形成闭包，需要满足以下几个条件：

1. 存在嵌套函数 ：在一个函数内部定义另一个函数。
2. 内部函数引用外部函数的变量 ：内部函数使用了外部函数作用域中的变量。
3. 外部函数返回内部函数 ：外部函数将内部函数作为返回值返回。
   
闭包的主要作用有以下几点：

1. 数据封装和隐藏 ：闭包可以将数据封装在内部函数中，外部无法直接访问，从而实现数据的隐藏。
2. 实现状态保持 ：闭包可以记住外部函数的状态，即使外部函数已经执行完毕，内部函数仍然可以访问和修改这些状态。
3. 代码复用 ：闭包可以作为一种函数工厂，根据不同的参数生成不同的函数，提高代码的复用性。

nonlocal 关键字
nonlocal 关键字用于在嵌套函数中引用并修改上一层（非全局）作用域中的变量。当你在嵌套函数内部想要修改外层函数的局部变量时，就需要使用 nonlocal 关键字进行声明。

```python
def outer():
    x = 10
    def inner():
        nonlocal x
        x = x + 1
        return x
    return inner

closure = outer()
print(closure())  # 输出 11
```

global 关键字
global 关键字用于在函数内部引用并修改全局变量。当你在函数内部想要修改一个全局作用域中定义的变量时，就需要使用 global 关键字进行声明。

判断以下代码的输出是什么
```python
a=10 
b=20 
c=30 
def do(): 
    print(a) 
    print(b) 
    print(c) 
    c+=1 
    print(c) 
do()
```

上述代码是有语法错误的。会下面的出现报错```UnboundLocalError:local variable 'c 'referenced before assignment```
可以修改成这样

```python
a=10 
b=20 
c=30 

def do(): 
    global c
    print(a) 
    print(b) 
    print(c) 
    c+=1 
    print(c) 
do()
```

### Python 虚拟环境

Python的虚拟环境（Virtual Environment），它允许你在同一台计算机上维护多个独立的Python环境，每个环境可以有自己独立的库和依赖项。虚拟环境的主要目的是解决不同项目之间的依赖冲突问题。
在Python中，可以使用venv模块（Python 3.3及以上版本）或第三方工具如virtualenv来创建虚拟环境。创建虚拟环境后，你可以在其中安装项目所需的库，而不会影响全局Python环境。

为什么要使用虚拟环境？
隔离依赖： 虚拟环境隔离不同项目的依赖，避免版本冲突和混乱。
版本兼容性： 不同项目可能需要不同版本的库，虚拟环境可以满足这种需求。
环境清洁： 当项目完成或不再需要时，可以轻松删除虚拟环境，而不会影响其他项目。


### Python 发行版

- 官方 Python 发行版
- Jyphon：Python 的 Java 实现版本

### Python 3.0

python3引入了一系列向后不兼容的变更。大多数不兼容的地方主要是：移除二义性和错误修正。

#### python2和python3的主要区别

[python2和python3的区别大全](https://blog.csdn.net/ljl6158999/article/details/78983725)

### Python和Java的区别

1、java需要定义变量类型
2、语句后要有 ;
3、{} 表示代码块
4、nums.length 和 len(nums)
5、Math.max() 和 max()


## metaclass/元类

YAMLObject：调用统一的 yaml.load()，就能把任意一个 yaml 序列载入成一个 Python Object；而调用统一的 yaml.dump()，就能把一个 YAMLObject 子类序列化。对于 load() 和 dump() 的使用者来说，他们完全不需要提前知道任何类型信息，这让超动态配置编程成了可能。



python 类型模型



Python 底层语言设计层面是如何实现 metaclass 的？

第一，所有的 Python 的用户定义类，都是 type 这个类的实例。

第二，用户自定义类，只不过是 type 类的__call__运算符重载。

第三，metaclass 是 type 的子类，通过替换 type 的__call__运算符重载机制，“超越变形”正常的类。

### ABCMeta

## 迭代器和生成器

参考 [如何更好地理解Python迭代器和生成器？
](https://www.zhihu.com/question/20829330)


### 迭代器（Iterators）

实现了**迭代器协议**的对象叫做迭代器，又叫做**可迭代对象**。

迭代器协议是指：对象需要实现了__iter__()和__next__()方法。
__iter__()方法返回迭代器对象本身
__next__()方法返回迭代的下一个值。当没有更多的值可供返回时，__next__()方法会引发StopIteration异常，终止迭代。

Python的内置工具(如for循环，sum，min，max函数等)使用迭代器协议访问对象。因此 for 循环不仅可以遍历数组，还可以用来遍历文件对象（文件对象实现了迭代器协议）。

判断对象是否可迭代

```python
isinstance(obj, Iterable)

def is_iterable(param): 
  try: 
    iter(param) 
    return True 
  except TypeError: 
    return False
```

生成一个包含一亿元素的列表。每个元素在生成后都会保存到内存中

```python
[i for i in range(100000000)]
```



### 生成器（Generators）

生成器是一种特殊的迭代器

创建一个生成器的语法
- 生成器函数：定义方式和常规函数几乎一样，区别是使用yield语句而不是return语句返回结果
- - 当函数执行到 return 语句时，会立即返回指定的值，并终止函数的执行。
- - 当函数执行到 yield 语句时，会暂停函数的执行，并返回一个值。每次调用生成器的 __next__() 方法时，函数会从上次暂停的地方继续执行。直到遇到下一个yield语句或函数结束。
- - 在 Python 2 中， xreadlines() 和 readlines() 是都是用于读取文件对象方法。readlines使用了return返回，而xreadlines使用了yield返回。
- 生成器表达式：生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表。列表推导，使用圆括号，就是一个生成器表达式。如下所示：

```python
(i for i in range(100000000))
```
生成器不需要显式实现__iter__()和__next__()方法，它们由Python自动实现迭代器协议。
生成器支持了延迟操作，更加简洁和高效。不会像迭代器一样保存整个序列在内存中，生成器在需要时才生成值。

注意事项：生成器只能遍历一次

生成器的优点包括: 

- 节省内存:因为它们一次只在内存中保留一个元素。 
- 延迟计算:只有在需要时才进行计算或数据处理。 
- 简化代码:使得代码更为简洁和易于理解。 
- 这种流式处理方式非常适合用于处理大文件、网络流数据或任何需要逐步处理的数据源。


项目中使用生成器的场景：
- 生成 step
- 实现流式返回。有效地处理大数据集或流式数据。
```python
def stream_data(data): 
  for item in data:  #这里可以对每个元素进行处理
    yield item 

#示例数据data=[1,2,3,4,5] 

#使用生成器进行流式处理
for value in stream_data(data): 
  print(value) 
```

### 区别和联系

- 迭代器和生成器都是用于遍历序列（例如列表、元组、字符串等）的工具
- 迭代器是一个有限集合，生成器则可以成为一个无限集。
- index_generator（生成器） 会返回一个 Generator 对象，需要使用 list 转换为列表后，才能用 print 输出。

### yield 关键字

通过 yield 可以让我们程序员实现对线程的调配，从而更加充分的利用的们的cpu

### yield from
[简述python的yield和yield from](https://juejin.cn/post/6844903507351306253)

## 上下文管理器，with

with 语句是用来创建上下文管理器的，而 with 语句搭配使用的对象要实现上下文管理器协议，这一协议涉及两个特殊方法（也被叫做 magic method）： \_\_enter__ 和 \_\_exit__ 。

[python黑魔法---上下文管理器（contextor）](https://www.jianshu.com/p/d53449f9e7e0)

使用方式
应用场景
原理


## 内存管理

### 内存分配机制
Python 使用一个私有堆内存空间来放置所有对象和数据结构，开发者无法直接访问这个堆内存，而是由 Python 解释器来管理它。Python 的内存分配机制主要分为以下几个层次：

#### 内存池
Python 通过内存池来减少内存碎片化，提高执行效率。内存池主要负责管理小对象（小于 512 字节）的内存分配。当需要分配小对象时，Python 会先从内存池中查找可用的内存块，而不是直接向操作系统请求内存。这样可以避免频繁的系统调用，提高内存分配的速度。
python通过内存池来减少内存碎片化，提高执行效率。

#### 大对象分配
对于大于 512 字节的大对象，Python 会直接向操作系统请求内存。这些对象的内存分配和释放由操作系统负责。

### 垃圾回收机制
Python 的垃圾回收机制主要通过以下三种方法来实现：


#### 引用计数
引用计数是 Python 最基本的垃圾回收方法。每个对象都有一个引用计数器，记录了有多少个变量引用了该对象。当引用计数器的值为 0 时，说明该对象不再被使用，Python 会自动回收该对象所占用的内存。

#### 标记 - 清除
引用计数方法无法解决循环引用的问题，即两个或多个对象相互引用，导致它们的引用计数永远不会为 0。为了解决这个问题，Python 引入了标记 - 清除算法。

标记 - 清除算法分为两个阶段：标记阶段和清除阶段。在标记阶段，Python 会从根对象（如全局变量、栈中的变量等）开始遍历所有可达的对象，并将它们标记为存活对象。在清除阶段，Python 会遍历所有对象，将未标记的对象视为垃圾对象，并回收它们所占用的内存。

####  分代回收
分代回收是基于 “对象存活时间越长，越不可能成为垃圾对象” 的假设。Python 将对象分为三代，分别为第 0 代、第 1 代和第 2 代。新创建的对象属于第 0 代，经过一定次数的垃圾回收后仍然存活的对象会被移动到下一代。

Python 会对不同代的对象采用不同的垃圾回收频率，第 0 代的对象回收频率最高，第 2 代的对象回收频率最低。这样可以提高垃圾回收的效率，减少不必要的垃圾回收操作。

总结：
引用计数为主，标记-清除、分代回收为辅。
通过引用计数来完成垃圾回收，通过标记-清除解决容器对象循环引用造成的问题，通过分代回收提高垃圾回收的效率。

当退出 Python 时是否释放所有内存分配？
不是。具有对象循环引用或者全局命名空间引用的变量，在 Python 退出是往往不会被释放另外不会释放 C 库保留的部分内容。

https://juejin.cn/post/6844903844116168718 


## GIL（Global Interpreter Lock，即全局解释器锁）

GIL，是最流行的 Python 解释器 CPython 中的一个技术术语。每一个 Python 线程，在 CPython 解释器中执行时，都会先锁住自己的线程，阻止别的线程执行。

CPython 使用引用计数来管理内存，查看引用计数的方法：sys.getrefcount(a)

CPython 引进 GIL 其实主要就是这么两个原因：

- 一是设计者为了规避类似于内存管理这样的复杂的竞争风险问题（race condition）；
- 二是因为 CPython 大量使用 C 语言库，但大部分 C 语言库都不是原生线程安全的（线程安全会降低性能和增加复杂度）。

CPython 中 check_interval 机制，CPython 解释器会去轮询检查线程 GIL 的锁住情况。每隔一段时间，Python 解释器就会强制当前线程去释放 GIL，这样别的线程才能有执行的机会。

绕过 GIL 的大致思路：

- 绕过 CPython，使用 JPython（Java 实现的 Python 解释器）等别的实现；
- 把关键性能代码，放到别的语言（一般是 C++）中实现。



## 掌握程度评判标准：
1.压根不知道语言的两个概念
2.会用，但是不了解原理
3.清楚原理，能灵活使用，举出自己使用的例子
4.能结合源码实现讲出语法特点，熟悉各种奇技淫巧